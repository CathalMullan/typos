#[test]
fn codegen() {
    const DICT: &[u8] = include_bytes!("../assets/words.csv");

    let mut trie_content = vec![];
    generate_trie(&mut trie_content, "WORD", DICT);
    let trie_content = String::from_utf8(trie_content).unwrap();
    let trie_content = codegenrs::rustfmt(&trie_content, None).unwrap();
    snapbox::assert_data_eq!(
        &trie_content,
        snapbox::file!["../benches/benches/trie_codegen.rs"].raw()
    );

    let mut map_content = vec![];
    generate_map(&mut map_content, "WORD", DICT);
    let map_content = String::from_utf8(map_content).unwrap();
    let map_content = codegenrs::rustfmt(&map_content, None).unwrap();
    snapbox::assert_data_eq!(
        &map_content,
        snapbox::file!["../benches/benches/map_codegen.rs"].raw()
    );

    let mut table_content = vec![];
    generate_table(&mut table_content, "WORD", DICT);
    let table_content = String::from_utf8(table_content).unwrap();
    let table_content = codegenrs::rustfmt(&table_content, None).unwrap();
    snapbox::assert_data_eq!(
        &table_content,
        snapbox::file!["../benches/benches/table_codegen.rs"].raw()
    );

    snapbox::assert_data_eq!(
        &trie_content,
        snapbox::file!["../src/word_codegen.rs"].raw()
    );
}

fn generate_trie<W: std::io::Write>(file: &mut W, prefix: &str, dict: &[u8]) {
    writeln!(
        file,
        "// This file is @generated by {}",
        file!().replace('\\', "/")
    )
    .unwrap();
    writeln!(file, "#![allow(clippy::unreadable_literal)]",).unwrap();
    writeln!(file, "#![allow(unreachable_pub)]",).unwrap();
    writeln!(file).unwrap();

    let records: Vec<_> = csv::ReaderBuilder::new()
        .has_headers(false)
        .flexible(true)
        .from_reader(dict)
        .records()
        .map(|r| r.unwrap())
        .collect();
    dictgen::generate_trie(
        file,
        prefix,
        "&'static [&'static str]",
        records.iter().map(|record| {
            let mut record_fields = record.iter();
            let key = record_fields.next().unwrap();
            let value = format!(
                "&[{}]",
                itertools::join(record_fields.map(|field| format!(r#""{field}""#)), ", ")
            );
            (key, value)
        }),
        64,
    )
    .unwrap();
}

fn generate_map<W: std::io::Write>(file: &mut W, prefix: &str, dict: &[u8]) {
    writeln!(
        file,
        "// This file is @generated by {}",
        file!().replace('\\', "/")
    )
    .unwrap();
    writeln!(file, "#![allow(clippy::unreadable_literal)]",).unwrap();
    writeln!(file, "#![allow(unreachable_pub)]",).unwrap();
    writeln!(file).unwrap();

    let records: Vec<_> = csv::ReaderBuilder::new()
        .has_headers(false)
        .flexible(true)
        .from_reader(dict)
        .records()
        .map(|r| r.unwrap())
        .collect();
    dictgen::generate_map(
        file,
        prefix,
        "&'static [&'static str]",
        records.iter().map(|record| {
            let mut record_fields = record.iter();
            let key = record_fields.next().unwrap();
            let value = format!(
                "&[{}]",
                itertools::join(record_fields.map(|field| format!(r#""{field}""#)), ", ")
            );
            (key, value)
        }),
    )
    .unwrap();
}

fn generate_table<W: std::io::Write>(file: &mut W, prefix: &str, dict: &[u8]) {
    writeln!(
        file,
        "// This file is @generated by {}",
        file!().replace('\\', "/")
    )
    .unwrap();
    writeln!(file, "#![allow(clippy::unreadable_literal)]",).unwrap();
    writeln!(file, "#![allow(unreachable_pub)]",).unwrap();
    writeln!(file).unwrap();

    let records: Vec<_> = csv::ReaderBuilder::new()
        .has_headers(false)
        .flexible(true)
        .from_reader(dict)
        .records()
        .map(|r| r.unwrap())
        .collect();
    dictgen::generate_table(
        file,
        prefix,
        "&'static [&'static str]",
        records.iter().map(|record| {
            let mut record_fields = record.iter();
            let key = record_fields.next().unwrap();
            let value = format!(
                "&[{}]",
                itertools::join(record_fields.map(|field| format!(r#""{field}""#)), ", ")
            );
            (key, value)
        }),
    )
    .unwrap();
}
